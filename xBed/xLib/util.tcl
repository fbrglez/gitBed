#------- keep here as a 80-character reference line to check text width -------#

proc walk.tables {
    {solverName     P.lop.saw}
    {instanceDef  N-pal11}
    {seedInit     1234}
    {walkLength   12345} 
    {aWalkProbed_ ""} } {
    
#-- begin ABOUT ---------------------------------------------------------------#
set thisCmd walk.tables
set ABOUT \
  "The command $thisCmd takes solverName, instanceDef, seedInit, walkLength,
and an array (as  a list aWalkProbed_) created under specific solverName.
After processing this array, the command creates three tables, ready to
be parsed and plotted in R as three views of the same walk:
*-walk-DownUp-probed, *-walk-DownUp, and *-walk-DownOnly."
    if {$solverName == "??"} { puts $ABOUT ; return }
    if {$solverName == "?"}  { error "Valid query is '$thisCmd ??'" ; return }
#-- end   ABOUT ---------------------------------------------------------------#
    
    array set aWalkProbed $aWalkProbed_     
    #parray aWalkProbed ; return
    
    set probedLines \
      "# This R-table has been created by the command '$thisCmd'.\
      \n# The tabulated data has been generated by solverName = $solverName,\
      \n# with instanceDef = $instanceDef, \
      seedInit = $seedInit, and walkLength = $walkLength \
      \n# on [join [clock format [clock seconds]]].\
      \n#\
      \nstep\tsegment\tcoord\tvalue\trank\tisPivot\tneighbSize\tcntProbe\n"
    set downUpLines $probedLines 
    set downOnlyLines $probedLines  ; set valuePrev 1e30
    foreach arg [lsort [array names aWalkProbed]] {
        set step       [lindex $aWalkProbed($arg) 0]
        set cntRestart [lindex $aWalkProbed($arg) 1]
        set coord      [lindex $aWalkProbed($arg) 2]
        set value      [lindex $aWalkProbed($arg) 3]
        set rank       [lindex $aWalkProbed($arg) 4]
        set isPivot    [lindex $aWalkProbed($arg) 5]
        set neighbSize [lindex $aWalkProbed($arg) 6]
        set cntProbe   [lindex $aWalkProbed($arg) 7]
        append probedLines \
          "$step\t$cntRestart\t$coord\t$value\t$rank\t$isPivot\t$neighbSize\t$cntProbe\n"
        
        if {$isPivot == 1} {
            append downUpLines \
              "$step\t$cntRestart\t$coord\t$value\t$rank\t$isPivot\t$neighbSize\t$cntProbe\n" 
            if {$value < $valuePrev} {
                append downOnlyLines \
                  "$step\t$cntRestart\t$coord\t$value\t$rank\t$isPivot\t$neighbSize\t$cntProbe\n" 
                set valuePrev $value
            } else {
                append downOnlyLines \
                  "$step\t$cntRestart\t$coord\t$valuePrev\t$rank\t$isPivot\t$neighbSize\t$cntProbe\n" 
            }
        }
    } 
    
##! Case: *-walk-DownUp-probed
    append fileName fg- $solverName - $instanceDef\
      -walk-DownUp- $seedInit - $walkLength -probed.txt 
    #puts $probedLines 
    file.write $fileName $probedLines
    puts ".. file $fileName has been created"
    
##! Case: *-walk-DownUp
    set fileName {}
    append fileName fg- $solverName - $instanceDef\
      -walk-DownUp- $seedInit - $walkLength .txt 
    #puts $downUpLines
    file.write $fileName $downUpLines
    puts ".. file $fileName has been created"
    
##! Case: *-walk-DownOnly
    set fileName {}
    append fileName fg- $solverName - $instanceDef\
      -walk-DownOnly- $seedInit - $walkLength .txt 
    #puts $downUpLines
    file.write $fileName $downOnlyLines
    puts ".. file $fileName has been created"
    
    return
#~dd 
# % P.lop.main ../xBenchm/lop/tiny/N-pal11.lop -seedInit 1 -isWalkTables
# 
# instanceDef           ../xBenchm/lop/tiny/N-pal11.lop
# solverName              P.lop.saw
# coordInit             2,9,7,8,6,5,10,3,11,4,1
# coordBest             2,7,5,8,6,9,10,11,3,1,4
# nDim                  11
# walkLengthLmt         2147483647
# walkLength            12
# cntRestartLmt         2147483647
# cntRestart            0
# cntProbeLmt           2147483647
# cntProbe              109
# runtimeLmt            30
# runtime               0.008678
# runtimeRead           0.001002
# speed                 12560
# hostID                brglez@belair-Darwin-14.3.0
# isSimple              1
# neighbDist            1
# solverMethod          saw
# walkSegmLmt           NA
# walkSegmCoef          NA
# walkIntervalLmt       NA
# walkIntervalCoef      NA
# walkRepeatsLmt        NA
# seedInit              1
# valueInit             -29
# valueBest             -35
# valueTarget           -35.0
# valueTol              0.0
# targetReached         1
# isCensored            0
# 
# .. file fg-P.lop.saw-N-pal11-walk-DownUp-1-12-probed.txt has been created
# .. file fg-P.lop.saw-N-pal11-walk-DownUp-1-12.txt has been created
# .. file fg-P.lop.saw-N-pal11-walk-DownOnly-1-12.txt has been created
# %
# Copyright:
# Franc Brglez, Sun Apr 19 07:00:16 EDT 2015
#~dd
    
} ;# walk.tables

proc table.info_variables_csv {
    {csvFile   ../../../xBed/xLib/util_data/P.lop.info_variables_csv} } {
#-- begin ABOUT ---------------------------------------------------------------#
set thisCmd table.info_variablescsv
set ABOUT \
"
This proc takes the : *info_variables_csv and creates a well-formatted 
easy-to-read file *info_variables.txt with three columns: 

       variableName          variableDefault    variableDescription

The file *info_variables.txt is read by a command *.info within a 
standardized combinatorial solver to

      (1) auto-generate a well-formatted response to user's query about  
          the solver command line
      
      (2) initialize all variables under the command *init
"
    if {$csvFile == "??"} { puts $ABOUT ; return }
    if {$csvFile == "?"}  { error "Valid query is '$thisCmd ??'" ; return }
#-- end   ABOUT ---------------------------------------------------------------#
    
    set csvFileName [file tail $csvFile]
    set headerLines "# This file has been created with the command 
# $thisCmd $csvFile
# on [join [clock format [clock seconds]]]
#
# This table documents principal variables defined under the file
# $csvFileName (exported from the original file *.numbers)
#
# Valid values that are interpreted default values for optional arguments include:
#   integers, reals, FALSE, NA, strings of contiguous non-space characters other 
#   than the two special keywords 'required' and 'internal'. These two keywords are
#   interpreted internally to the program and do not represent optional arguments.
#
# Characters ';' and '\"' should be excluded from variable description.
#
# All variable descriptions are limited to 80 characters per line; if description
# is on more than a single line, values of variableName and variableDefault must be 
# repeated for each continuation line.
#
# variableName	     variableDefault	variableDescription"
    
    # read csvFile 
    set tmpList  [split [file.read $csvFile] \n] 
    foreach line $tmpList {lappend rList $line}
    
    set maxChars 0
    foreach line $rList {
        
        set nChars [string length $line] ; set cntCommas 0
        set varName {} ; set varDefault {} ; set varInfo {}
        
        for {set i 0} {$i < $nChars} {incr i} {

            set char [string index $line $i] ; set isComma 0
            if {$char == ","} {
                set $isComma 1 
                incr cntCommas ;# puts \ncntCommas=$cntCommas
            }
            if {      !$isComma && $cntCommas == 0} {
                append varName [string index $line $i] 
                
            } elseif {!$isComma && $cntCommas == 1} {
                append varDefault [string index $line $i+1]
                
            } elseif {!$isComma && $cntCommas >= 2} {
                append varInfo [string index $line $i+1]
                
            }
        }
        set varName         [string trim $varName " "]
        set varDefault      [string trimright $varDefault ","]
        set varNameChars    [string length $varName]
        set varDefaultChars [string length $varDefault]
        if {$varNameChars    > $maxChars}  {set maxChars $varNameChars}
        if {$varDefaultChars > $maxChars}  {set maxChars $varDefaultChars}        
        set     all_valu($varName) [string trimright $varDefault ","]
        lappend all_info($varName) [string trim $varInfo "\""]
    }
    #parray all_info ; parray all_valu
    
    # initialize contents for the table *.info_variables.txt
    set rowlines  $headerLines\n
    
    # create "pretty" space-separated columns of 
    # variables names, default values, and variable descriptions
    foreach name [lsort [array names all_valu]] {
        
        set chars1 [expr {3 + $maxChars - [string length $name]}]
        set chars2 [expr {3 + $maxChars - [string length $all_valu($name)]}]
        set space1 [string repeat " " $chars1]
        set space2 [string repeat " " $chars2]
        foreach descr $all_info($name) {
            append rowlines $name $space1 $all_valu($name) $space2 $descr \n
        }
    }
    #puts $rowlines\n ; return
    # write the  these rowlines into a file
    set fileName [file rootname $csvFile].txt
    file.write $fileName $rowlines
    puts ".. file $fileName has been created"
#~dd
# % pwd
# /Users/brglez/Sites/~SYNC/gitPublic/xProj/B.gvc/xWork
# % source ../xLib/all_tcl
# # .. sourced all tcl libraries defined under the sandbox (see the file all_tcl)
# % table.info_variables_csv ../xLib/B.gvc.info_variables_csv
# .. file ../xLib/B.gvc.info_variables.txt has been created
# % pwd
# /Users/brglez/Sites/~SYNC/gitPublic/xProj/B.gvc/xWork
# Copyright
# Franc Brglez, Tue May 26 10:34:53 EDT 2015
#~dd  
} ;# table.info.info_variables_csv

proc table.info_variables {
    {fileName   ../../../xBed/xLib/util_data/P.lop.info_variables.txt}
    {ABOUT "This proc takes a file *info_variables.txt and returns two associative
    arrays: all_info and all_valu. Both arrays are indexed with the same
    variable names; the array all_info associates with variable default values, 
    and the array all_valu associates with brief variable descriptions. 
    Both arrays are needed to
      (1) generate a response to user's query about the command line
      (2) initialize all variables under the command *init"} } {
    
    set thisCmd table.info_variables 
    # extract uncommented lines from the table
    set tmpList [split [file.read $fileName] \n]  
    foreach line $tmpList {
        set firstChar [string index $line 0] 
        if {$firstChar != "#" && [llength $line] > 0} {
            lappend rList $line
        }
    }          
    array unset all_info   ; array unset all_valu   
    
    foreach line $rList {
        #puts line=$line
        if {$line != {}} {
            set varName    [lindex $line 0]
            set varDefault [lindex $line 1]
            set varInfo    [lrange $line 2 end]
            
            lappend all_info($varName) $varInfo
            set     all_valu($varName) $varDefault
        }
    }
    #parray all_info ; parray all_valu 
    return [list [array get all_info] [array get all_valu] ]   
#~dd 
# % table.info_variables
# all_info(cntProbe)         = {Counts the number of objective function invocations.}
# all_info(cntProbeLmt)      = {Stop if the solver reaches this value.}
# all_info(cntRestart)       = {Counts the number of restarts internal to the solver.}
# all_info(cntRestartLmt)    = {Stop if the solver reaches this value.}
# ...
# ...
# all_info(walkLengthLmt)    = {Stop if the solver reaches this value.}
# all_info(walkRepeatsLmt)   = {Inactive unless assigned an integer. If an integer, the walk is} {monitored for repeats of valueBest. If walkRepeats > walkRepeatsLmt,} {the self-avoiding walk branches from another coordinate with valueBest.}
# all_info(walkSegmCoef)     = {A coefficient that determines walkSegmLmt as walkSegmCoef*nDim.}
# all_info(walkSegmLmt)      = {Inactive unless assigned an integer or if walkSegmCoef is assigned a real value.}
# 
# all_valu(cntProbe)         = internal
# all_valu(cntProbeLmt)      = 2147483647
# all_valu(cntRestart)       = internal
# all_valu(cntRestartLmt)    = 2147483647
# ...
# ...
# all_valu(walkLengthLmt)    = 2147483647
# all_valu(walkRepeatsLmt)   = NA
# all_valu(walkSegmCoef)     = NA
# all_valu(walkSegmLmt)      = NA
#
# Copyright
# Franc Brglez, Sat Mar 07 16:45:31 EST 2015
#~dd    
} ;# table.info_variables

proc table.html {
    {fileName   ../../../xLib/util/table_test/util.table_test-sample.txt}
    {commentChar "\#"} 
    {ABOUT "... see an example run before the end of this proc"} } {
    
    set thisCmd table.html 
    
    # extract the table
    set rList         [file.read.tableInR $fileName] ;# return
    set commentLines  [lindex $rList 0]
    set columnLabels  [lindex $rList 1]
    array set dataAry [lindex $rList 2]
    
    #parray dataAry ; return

    set nColumns [llength $columnLabels]
    set header "\
      \n<!doctype html public \"-//w3c//dtd html 4.0 transitional//en\"> \
      \n<html> \
      \n<head> \
      \n<meta \
      http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"> \
      \n</head> \
      \n<body> \
      \n<table BORDER COLS=$nColumns WIDTH=\"100%\" > \
      "
    set footer "\
      \n</table> \
      \n</body> \
      \n</html> \
      "
    # create the top-part of the htmlTable
    append htmlTable $header \n
    set comments  "\# fileName = [file rootname $fileName].html\
      \n\# created with the command $thisCmd \
      \n\# on [clock format [clock seconds] -gmt 0]\
      \n$commentLines\n"
    append htmlTable <pre> \n$comments \n</pre> \n   
    
    # start the body of htmlTable  
    append tableBody <tr><td> [join $columnLabels </td><td>]  </td></tr> \n
    
    # complete the body of htmlTable  
    set col0 [lindex $columnLabels 0]
    for {set idx 0} {$idx < [llength $dataAry($col0)]} {incr idx} {
        set rowLine {}
        foreach col $columnLabels {
            lappend rowLine [lindex $dataAry($col) $idx]
        }
        append tableBody <tr><td> [join $rowLine </td><td>]  </td></tr> \n
    }
    # complete the htmlTable    
    append htmlTable $tableBody
    append htmlTable $footer
    
    file.write [file rootname $fileName].html $htmlTable
    puts ".. The command $thisCmd created the file\n[file rootname $fileName].html"
#~dd    
# % table.html
# .. invoking file.read from file.read.tableInR
# .. file ../../../xLib/util/util.table_test-sample.html has been created
# % 
#
# Copyright
# Franc Brglez, Mon Aug 04 13:06:58 EDT 2014
#~dd    
} ;# table.html

proc table.sample.coordUniq { 
    {sampleFile  ../../../xBed/xLib/util_data/xPer-P.lopT-config2-pal-13-100-1901-sample.txt} } {
       
    set thisCmd table.sample.coordUniq
    set ABOUT "The proc $thisCmd ....."
    
    # read the table *-sample.txt
    set rList [file.read.tableInR $sampleFile] 
    set comments        [lindex $rList 0]
    set columnLabels    [lindex $rList 1]
    array set tableAry  [lindex $rList 2] ;# parray tableAry  ;# return
    
    set coordAll  $tableAry(coordBest)
    set sizeAll   [llength $coordAll]
    
    set coordUniq [lsort -uniq $coordAll]
    set sizeUniq  [llength $coordUniq]
    
    set fileCoordUniq [file rootname $sampleFile]-coordUniq.txt
    set coordHeader "# created by the command $thisCmd\
      \n# coordUniq=$sizeUniq (from the original coordAll=$sizeAll)\
      \ncoordBestUnique"
    file.write $fileCoordUniq $coordHeader\n[join $coordUniq \n] 
    
    puts ".. The command $thisCmd found $sizeUniq unique coordinates (from $sizeAll)\
      and created the file\n$fileCoordUniq"
    
    # create also the respective html file
    table.html  $fileCoordUniq  
    return

#~dd 
# % table.sample.coordUniq ../../../xBed/xLib/util_data/xPer-P.lopT-config2-pal-13-100-1901-sample.txt
# .. invoking file.read from file.read.tableInR
# .. The command table.sample.coordUniq found 81 unique coordinates (from 100) and created the file
# ../../../xBed/xLib/util_data/xPer-P.lopT-config2-pal-13-100-1901-sample-coordUniq.txt
# % 
# Copyright
# Franc Brglez, Tue Apr 21 12:38:50 EDT 2015
#~dd  
} ;# table.sample.coordUniq
     

#------- keep here as a 80-character reference line to check text width -------#

proc table.sample.coord.labs { 
    {fileDir    ../../../xLib/util/B.labs}
    {ABOUT  "...."} } {
       
    set thisCmd table.sample.coord
    set ABOUT "The proc $thisCmd ....."
    
    # read all files  *-sample.txt
    set workDir [pwd]
    cd $fileDir
    set fileList [glob *-sample.txt]
    puts [join $fileList \n] ; cd $workDir ;# return
    
    foreach file $fileList {
        set rList [file.read.tableInR $file]
        set comments        [lindex $rList 0]
        set columnLabels    [lindex $rList 1]
        array set tableAry  [lindex $rList 2] ;# parray tableAry  ;# return
        if {[lsearch -inline $columnLabels instanceDim] != "instanceDim"} {
            error "\nERROR from $thisCmd\
              \n... instanceDim is missing from the \
              \n    columnLabels = $columnLabels\
              \n    in file = $file\n"
        }
        if {[lsearch -inline $columnLabels coordBest] != "coordBest"} {
            error "\nERROR from $thisCmd\
              \n... coordBest is missing from the \
              \n    columnLabels = $columnLabels\
              \n    in file = $file\n"
        }
        if {[lsearch -inline $columnLabels targetReached] != "targetReached"} {
            error "\nERROR from $thisCmd\
              \n... targetReached is missing from the \
              \n    columnLabels = $columnLabels\
              \n    in file = $file\n"
        }
        if {[lsearch -inline $columnLabels targetReached] != "solverName"} {
            error "\nERROR from $thisCmd\
              \n... solverName is missing from the \
              \n    columnLabels = $columnLabels\
              \n    in file = $file\n"
        }
        if {[lsearch -inline $columnLabels targetReached] != "sampleID"} {
            error "\nERROR from $thisCmd\
              \n... sampleID is missing from the \
              \n    columnLabels = $columnLabels\
              \n    in file = $file\n"
        }
        set tableAry(instanceDim) 
    }
    
        
    
    # check if the file has the expected column names
    set validNames [concat "solverName instanceDim" $statsVarList]
    set colNames   [array names tableAry]
    set missingNames {}
    foreach name $validNames {
        set idx [lsearch $colNames $name]
        if {$idx < 0} {lappend missingNames $name}
    }
    if {$missingNames != {}} {
        error "\nERROR from $thisCmd:\
          \n... these names \
          \n... $missingNames\
          \n... do not exist as column names in file $sampleFile"
    }
    # extract values for each variate (i.e. random variable)
    foreach var $statsVarList {
        set varAry($var) $tableAry($var)
    }
    #parray varAry ;# return         
    
    
    
    set rList [file.read.tableInR $sampleFile] 
    set comments        [lindex $rList 0]
    set columnLabels    [lindex $rList 1]
    array set tableAry  [lindex $rList 2] ;# parray tableAry  ;# return
    
    # check if the file has the expected column names
    set validNames [concat "solverName instanceDim" $statsVarList]
    set colNames   [array names tableAry]
    set missingNames {}
    foreach name $validNames {
        set idx [lsearch $colNames $name]
        if {$idx < 0} {lappend missingNames $name}
    }
    if {$missingNames != {}} {
        error "\nERROR from $thisCmd:\
          \n... these names \
          \n... $missingNames\
          \n... do not exist as column names in file $sampleFile"
    }
    # extract values for each variate (i.e. random variable)
    foreach var $statsVarList {
        set varAry($var) $tableAry($var)
    }
    #parray varAry ;# return 
    
    # generate values for table *-stats.txt
    set instanceDim [lindex  $tableAry(instanceDim) 0]
    set solverName      [lindex  $tableAry(solverName)      0]
    set sampleSize    [llength $tableAry(runtime)]
    
    set statsCols "statsVar solverName instanceDim hitRatio cntCensored \
      sampleSize median mean  stdDev coefVar stdErr meanLB95 meanUB95 \
      minVal maxVal median2mean minVal2mean maxVal2mean"
    set statsRows [join $statsCols \t]\n
    
    foreach var $statsVarList { 
        
        set cntCensored   0
        array unset statsAry
        array set statsAry [stats.all13 $tableAry($var)]
        
        # augment statsAry with additional values
        for {set idx 0} {$idx < $sampleSize} {incr idx} {  
            if {![lindex $tableAry(targetReached) $idx]} {incr cntCensored}
        }
        set hitRatio [expr {($sampleSize - $cntCensored)/double($sampleSize)}]
        set hitRatio [format "%0.4f" $hitRatio] 
        set statsAry(statsVar)      $var
        set statsAry(solverName)      $solverName
        set statsAry(instanceDim) $instanceDim
        set statsAry(hitRatio)      $hitRatio
        set statsAry(cntCensored)   $cntCensored
        set statsAry(sampleSize)    $sampleSize
        #puts \nvar=$var ; parray statsAry
        
        # create a rowLine for statsFile
        set rowLine {}
        foreach col $statsCols {lappend rowLine $statsAry($col)}
        append statsRows [join $rowLine \t]\n
    }
    #puts \nstatsRows\n$statsRows ; return
    
    set fileStats [file rootname $sampleFile]-stats.txt
    file delete -force $fileStats
    set statsHeader "\# file = $fileStats\
      \n\# this file has been generated on [join [clock format [clock seconds] -gmt 0]] from\
      \n\# file = $sampleFile \
      \n\# using command $thisCmd\
      \n\#"
    file.write $fileStats $statsHeader\n$statsRows 
    puts ".. file $$fileStats has been created"
        
    # create also the respective html file
    table.html  $fileStats
#~dd 
# % table.sample.stats ../../../xLib/util/util.table_test-sample.txt
# .. invoking file.read from file.read.tableInR
# .. file $../../../xLib/util/util.table_test-sample-stats.txt has been created
# .. invoking file.read from file.read.tableInR
# .. file ../../../xLib/util/util.table_test-sample-stats.html has been created
# % 
# 
# Copyright
# Franc Brglez, Mon Aug 04 13:25:57 EDT 2014
#~dd  
} ;# table.sample.coord.labs

proc table.sample.stats { 
    {sampleFile    ../../../xLib/util/util.table_test-sample.txt}
    {statsVarList  "runtime cntProbe walkLength cntRestart speedProbe"} } {
       
    set thisCmd table.sample.stats
    set ABOUT "The proc $thisCmd ....."
    
    # needs also the fix for
    # statsVarList  "runtime cntProbe walkLength cntRestart speedProbe 
    # cntOther speedOther"
    
    # read the table *-sample.txt
    set rList [file.read.tableInR $sampleFile] 
    set comments        [lindex $rList 0]
    set columnLabels    [lindex $rList 1]
    array set tableAry  [lindex $rList 2] ;# parray tableAry  ;# return
    
    # check if the file has the expected column names
    set validNames [concat "solverName instanceDim" $statsVarList]
    set colNames   [array names tableAry]
    set missingNames {}
    foreach name $validNames {
        set idx [lsearch $colNames $name]
        if {$idx < 0} {lappend missingNames $name}
    }
    if {$missingNames != {}} {
        error "\nERROR from $thisCmd:\
          \n... these names \
          \n... $missingNames\
          \n... do not exist as column names in file $sampleFile"
    }
    # extract values for each variate (i.e. random variable)
    foreach var $statsVarList {
        set varAry($var) $tableAry($var)
    }
    #parray varAry ;# return 
    
    # generate values for table *-stats.txt
    set instanceDim   [lindex  $tableAry(instanceDim) 0]
    set solverName    [lindex  $tableAry(solverName)  0]
    set sampleSize    [llength $tableAry(runtime)]
    
    set statsCols "statsVar solverName instanceDim hitRatio cntCensored \
      sampleSize median mean  stdDev coefVar stdErr meanLB95 meanUB95 \
      minVal maxVal median2mean minVal2mean maxVal2mean"
    set statsRows [join $statsCols \t]\n
    
    foreach var $statsVarList { 
        
        set cntCensored   0
        array unset statsAry
        array set statsAry [stats.all13 $tableAry($var)]
        
        # augment statsAry with additional values
        for {set idx 0} {$idx < $sampleSize} {incr idx} {  
            if {![lindex $tableAry(targetReached) $idx]} {incr cntCensored}
        }
        set hitRatio [expr {($sampleSize - $cntCensored)/double($sampleSize)}]
        set hitRatio [format "%0.4f" $hitRatio] 
        set statsAry(statsVar)      $var
        set statsAry(solverName)      $solverName
        set statsAry(instanceDim) $instanceDim
        set statsAry(hitRatio)      $hitRatio
        set statsAry(cntCensored)   $cntCensored
        set statsAry(sampleSize)    $sampleSize
        #puts \nvar=$var ; parray statsAry
        
        # create a rowLine for statsFile
        set rowLine {}
        foreach col $statsCols {lappend rowLine $statsAry($col)}
        append statsRows [join $rowLine \t]\n
    }
    #puts \nstatsRows\n$statsRows ; return
    
    set fileStats [file rootname $sampleFile]-stats.txt
    file delete -force $fileStats
    set statsHeader "\# file = $fileStats\
      \n\# this file has been generated on [join [clock format [clock seconds] -gmt 0]] from\
      \n\# file = $sampleFile \
      \n\# using command $thisCmd\
      \n\#"
    file.write $fileStats $statsHeader\n$statsRows 
    puts ".. The command $thisCmd created the file\n$fileStats"
        
    # create also the respective html file
    table.html  $fileStats
#~dd 
# % table.sample.stats ../../../xLib/util/util.table_test-sample.txt
# .. invoking file.read from file.read.tableInR
# .. file $../../../xLib/util/util.table_test-sample-stats.txt has been created
# .. invoking file.read from file.read.tableInR
# .. file ../../../xLib/util/util.table_test-sample-stats.html has been created
# % 
# 
# Copyright
# Franc Brglez, Mon Aug 04 13:25:57 EDT 2014
#~dd  
} ;# table.sample.stats


proc stats.all13 {
    {dataList "1 2 3 NA 4 5 6 NA 7 8 9"} } {

    set thisCmd stat.all13
    # validate dataList
    set tmpList {}
    foreach val $dataList {
        if {[string is integer -strict $val] || \
           [string is double -strict $val] } {
            lappend tmpList [expr {double($val)}]
        }
    }
    set dataList $tmpList  ;  set N [llength $dataList]
    #puts N=$N...dataList=$dataList
    set listOf13 {
        sampleSize median mean stdDev coefVar stdErr meanLB95 meanUB95
        minVal  maxVal  median2mean minVal2mean  maxVal2mean
    }
    set sampleSize $N
    if {$N < 5} {
        set median     NA
        set mean       NA
        set stdDev     NA
        set stdErr     NA
        set coefVar    NA
        set meanLB95   NA
        set meanUB95   NA
        set minVal     NA
        set maxVal     NA
        set median2mean NA
        set minVal2mean NA
        set maxVal2mean NA

        set nameValueList {}
        foreach name $listOf13 {
            set value [eval subst  {[set $name]}]
            lappend nameValueList $name
            lappend nameValueList $value
        }
        return $nameValueList
    }
    set dof [expr {$N - 1}] ;# degrees-of-freedom
    set sum 0. ;  set sumsq 0.
    foreach val $dataList {
        set sum [expr {$sum + $val}] ; set sumsq [expr {$sumsq + $val*$val}]
    }
    set mean     [expr {$sum/$N}]
    set variance [expr {($sumsq - $N*$mean*$mean)/$dof}]
    if {$variance < 0.0} {set variance 0.0}
    set stdDev   [expr {sqrt(abs($variance))}]
    set stdErr   [expr {$stdDev/sqrt($N)}]

    # sort dataList to find minVal, maxVal, and median
    set dataList [lsort -real $dataList]
    set minVal  [lindex $dataList 0] ; set maxVal [lindex $dataList end]

    if {[expr {$N % 2}]} {
        set midPoint [expr {int($N/2)}]
        set median   [lindex $dataList $midPoint]
    } else {
        set midPoint [expr {int($N/2)}]
        set median1  [lindex $dataList [expr  {$midPoint -1}]]
        set median2  [lindex $dataList $midPoint]
        set median   [expr {0.5*($median1 + $median2)}]
    }
    set tCoeff   [stats.tCoeff95 $dof] ;# herem dof >= 7!!
    set delta    [expr {$tCoeff*$stdDev/sqrt($dof)}]
    set meanLB95 [expr {$mean - $delta}]
    set meanUB95 [expr {$mean + $delta}]
    set mean  [expr {(double($mean))}]
    if {[expr {abs($mean)}] > 1e-4} {
        set coefVar [expr {($stdDev/abs($mean))}]
        set median2mean [expr {$median/$mean}]
        set minVal2mean [expr {$minVal/$mean}]
        set maxVal2mean [expr {$maxVal/$mean}]
    } else {
        set coefVar     NA
        set median2mean NA
        set minVal2mean NA
        set maxVal2mean NA
    }
    set nameValueList {}
    foreach name $listOf13 {
        set value [eval subst  {[set $name]}]
        if {[string is double -strict $value]} {
            set value [format "%0.7g" $value]
        } else {
            set value NA
        }
        lappend nameValueList $name
        lappend nameValueList $value
    }
    return $nameValueList
#~dd
# % stat.all13 "1 2 3 NA 4 5 6 NA 7 8 9"
# sampleSize 9 median 5 mean 5 stdDev 2.738613 coefVar 0.5477226
# stdErr 0.9128709 meanLB95 2.793287 meanUB95 7.206713
# minVal 1 maxVal 9 median2mean 1 minVal2mean 0.2 maxVal2mean 1.8
#
# Copyright
# Franc Brglez, Mon Aug 20 21:01:55 EDT 2012
#~dd
} ;# stats.all13

proc stats.tCoeff95 {degrees_of_freedom} {
##
    set N $degrees_of_freedom

    if {$N < 3} {
        error \
          "Degrees of freedom $N is less than 3 (less than 4 data samples).\
          Increase this value in order to find the value of t-coefficient."
    }
    if {$N == 3} {
        set tValue 3.182
        return $tValue
    }
    if {$N >= 4 && $N < 9} {
        set tValue [expr {-0.678243*log($N) + 3.689450}]
        return $tValue
    }
    if {$N >= 9 && $N < 20} {
        set tValue [expr {-0.2234449*log($N) + 2.740068}]
        return $tValue
    }
    if {$N >= 20 && $N < 30} {
        set tValue [expr {-0.1101766*log($N) + 2.415266}]
        return $tValue
    }
    if {$N >= 30 && $N < 240} {
        set tValue [expr {-0.03669181*log($N) + 2.157684}]
        return $tValue
    }
    if {$N >= 240} {
        set tValue 1.96
        return $tValue
    }
# proc stat.tCoeff95
# returns the value of t-coefficient (95% conf.) for degrees-of-freedom > 3!!
# tValues={4  2.75} {5  2.60} {6  2.47} {7  2.37} {8  2.28} {9  2.25}
# {10  2.23} {11  2.20} {12  2.18} {13  2.17} {14  2.15} {15  2.13} {16  2.12}
# {17  2.11} {18  2.09} {19  2.08} {20  2.09} {21  2.08} {22  2.07} {24  2.07}
# {26  2.06} {28  2.05} {29  2.04} {30  2.03} {31  2.03} {32  2.03} {33  2.03}
# {40  2.02} {41  2.02} {50  2.01} {59  2.01} {60  2.01} {61  2.01}
# {100  1.99} {120  1.98} {240  1.96} {250  1.96} {1000  1.96}
#
} ;# stats.tCoeff95

proc rand.reseed {
    {seedInit 1942}
    {ABOUT "This command takes an integer seed an initializes a RNG twice:
    first pass is with the seed given, second pass is with a random seed
    in range (0, 1000000000), generated on 128-th call to rand().
    The value of this random seed is also returned. Merits of this command
    have been observed during performance evaluations of combinatorial
    algorithms under randomized instantiations. If the random seed is recorded,
    these experiments are also reproducible."} } {

    # the reseeding command below is critical, in particular
    # if (tcl) solver is invokign the same random number generator
    set init [expr {srand($seedInit)}]    ;# this may not be enough!!
    for {set i 0} {$i < 128} {incr i} {
    	set rnd [expr {rand()}]
    }
    set seed [expr {int(1e9*$rnd)}]
    set init [expr {srand($seed)}]        ;# this is BETTER
    #puts ".. initialized RNG with seed=$seedInit; re-initialized after 128 calls to rand()."
    return $seed
} ;# rand.reseed